{"version":3,"file":"index.esm.js","sources":["../tsc-out/intrinsicclass.js","../tsc-out/slots.js","../tsc-out/calendar.js","../tsc-out/ecmascript.js","../tsc-out/regex.js","../tsc-out/intl.js","../tsc-out/instant.js","../tsc-out/plaindate.js","../tsc-out/plaindatetime.js","../tsc-out/duration.js","../tsc-out/plainmonthday.js","../tsc-out/now.js","../tsc-out/plaintime.js","../tsc-out/timezone.js","../tsc-out/plainyearmonth.js","../tsc-out/zoneddatetime.js","../tsc-out/legacydate.js","../tsc-out/index.js"],"sourcesContent":["import { DEBUG } from './debug';\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nexport function MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    if (DEBUG) {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nexport function DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nexport function GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n//# sourceMappingURL=intrinsicclass.js.map","// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nexport function CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nexport function HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nexport function GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nexport function SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n//# sourceMappingURL=slots.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport { CALENDAR_ID, ISO_YEAR, ISO_MONTH, ISO_DAY, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, HasSlot, SetSlot } from './slots';\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ES.ToString(idParam);\n        if (!IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        const duration = ES.ToTemporalDuration(durationParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const { days } = ES.BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalCalendar(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n        return ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return ES.CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return ES.DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            ES.RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ES.ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ES.ISOYearString(isoYear);\n    const monthString = ES.ISODateTimePartString(isoMonth);\n    const dayString = ES.ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            ES.RejectToRange(month, 1, largestMonth);\n            ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ES.ConstrainToRange(month, 1, largestMonth);\n            day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = ES.PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n        const date2 = ES.PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n        if (date1.year !== date2.year)\n            return ES.ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ES.ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ES.ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, month, day } = calendarDate;\n        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = ES.DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month > 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n                    ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year – if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, largestMonth);\n                    ES.RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, largestMonth);\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = ES.CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = ES.CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\nexport function IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n//# sourceMappingURL=calendar.js.map","const ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply = Reflect.apply;\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { CreateSlots, GetSlot, HasSlot, SetSlot, EPOCHNANOSECONDS, TIMEZONE_ID, CALENDAR_ID, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, DATE_BRAND, YEAR_MONTH_BRAND, MONTH_DAY_BRAND, TIME_ZONE, CALENDAR, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS } from './slots';\nimport { IsBuiltinCalendar } from './calendar';\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = JSBI.multiply(JSBI.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nexport function IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nexport function ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nexport function ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nexport function ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nexport function ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nexport function ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // ℝ(value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = JSBI.divide(x, y);\n    const remainder = JSBI.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (JSBI.lessThan(x, ZERO))\n        return JSBI.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst ALLOWED_UNITS = [\n    'year',\n    'month',\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year'],\n    ['months', 'month'],\n    ['weeks', 'week'],\n    ['days', 'day'],\n    ['hours', 'hour'],\n    ['minutes', 'minute'],\n    ['seconds', 'second'],\n    ['milliseconds', 'millisecond'],\n    ['microseconds', 'microsecond'],\n    ['nanoseconds', 'nanosecond']\n];\nimport * as PARSE from './regex';\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nexport function IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nexport function IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nexport function IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nexport function IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = PARSE.zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\nfunction ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\nfunction ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\nfunction ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalTimeString(isoString) {\n    const match = PARSE.time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\nfunction ParseTemporalYearMonthString(isoString) {\n    const match = PARSE.yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\nfunction ParseTemporalMonthDayString(isoString) {\n    const match = PARSE.monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\nfunction ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent) {\n            canonicalIdent = canonicalIdent.toString();\n            if (TestTimeZoneOffsetString(canonicalIdent))\n                return { offset: canonicalIdent };\n            return { ianaName: canonicalIdent };\n        }\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\nfunction ParseTemporalDurationString(isoString) {\n    const match = PARSE.duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ParseTemporalInstant(isoString) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n}\nexport function RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nexport function RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const props = ToPartialRecord(item, [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n    ]);\n    if (!props)\n        throw new TypeError('invalid duration-like');\n    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function ToLimitedTemporalDuration(item, disallowedProperties = []) {\n    let record;\n    if (IsObject(item)) {\n        record = ToTemporalDurationRecord(item);\n    }\n    else {\n        const str = ToString(item);\n        record = ParseTemporalDurationString(str);\n    }\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nexport function ToTemporalOverflow(options) {\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nexport function ToTemporalDisambiguation(options) {\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nexport function ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nexport function NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nexport function ToTemporalOffset(options, fallback) {\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nexport function ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nexport function ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nexport function ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nexport function ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nexport function ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nexport function ToSecondsStringPrecision(options) {\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n        default: // fall through if option not given\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nexport function ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n    if (retval === 'auto' && autoValue !== undefined)\n        return autoValue;\n    if (singular.has(retval)) {\n        return singular.get(retval);\n    }\n    return retval;\n}\nexport function ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nexport function ToTemporalDurationTotalUnit(options) {\n    // This AO is identical to ToSmallestTemporalUnit, except:\n    // - default is always `undefined` (caller will throw if omitted)\n    // - option is named `unit` (not `smallestUnit`)\n    // - all units are valid (no `disallowedStrings`)\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nexport function ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n        const dateOptions = ObjectCreate(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nexport function ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n    if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n}\nexport function DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0)\n            return singular.get(prop);\n    }\n    return 'nanosecond';\n}\nexport function LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nexport function ToPartialRecord(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    let any = false;\n    let result = {};\n    for (const property of fields) {\n        const value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                result[property] = BUILTIN_CASTS.get(property)(value);\n            }\n            else {\n                result[property] = value;\n            }\n        }\n    }\n    return any ? result : false;\n}\nexport function PrepareTemporalFields(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    const result = {};\n    let any = false;\n    for (const fieldRecord of fields) {\n        const [property, defaultValue] = fieldRecord;\n        let value = bag[property];\n        if (value === undefined) {\n            if (fieldRecord.length === 1) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = defaultValue;\n        }\n        else {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n        }\n        result[property] = value;\n    }\n    if (!any) {\n        throw new TypeError('no supported properties found');\n    }\n    if ((result['era'] === undefined) !==\n        (result['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\n// field access in the following operations is intentionally alphabetical\nexport function ToTemporalDateFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalMonthDayFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalTimeRecord(bag) {\n    return PrepareTemporalFields(bag, [\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['nanosecond', 0],\n        ['second', 0]\n    ]);\n}\nexport function ToTemporalYearMonthFields(bag, fieldNames) {\n    const entries = [\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined],\n        ['offset', undefined],\n        ['timeZone']\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalDate(itemParam, options = ObjectCreate(null)) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalDateFields(item, fieldNames);\n        return DateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nexport function InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = DateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function ToTemporalDateTime(item, options = ObjectCreate(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function ToTemporalDuration(item) {\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (IsObject(item)) {\n        if (IsTemporalDuration(item))\n            return item;\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ToTemporalDurationRecord(item));\n    }\n    else {\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ParseTemporalDurationString(ToString(item)));\n    }\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nexport function ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nexport function ToTemporalMonthDay(item, options = ObjectCreate(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalMonthDayFields(item, fieldNames);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    const canonicalOptions = ObjectCreate(null);\n    return MonthDayFromFields(calendar, result, canonicalOptions);\n}\nexport function ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nexport function ToTemporalYearMonth(item, options = ObjectCreate(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(item, fieldNames);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    const canonicalOptions = ObjectCreate(null);\n    return YearMonthFromFields(calendar, result, canonicalOptions);\n}\nexport function InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nexport function ToTemporalZonedDateTime(item, options = ObjectCreate(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nexport function CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    if (DEBUG) {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nexport function CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, µs);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n    return result;\n}\nexport function CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nexport function CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nexport function CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nexport function GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush.call(result, name);\n    }\n    return result;\n}\nexport function CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nexport function CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nexport function CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nexport function CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nexport function CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nexport function CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nexport function CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nexport function CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nexport function CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nexport function CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nexport function CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nexport function CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nexport function CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nexport function ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nexport function CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nexport function ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nexport function DateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function YearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function MonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nexport function TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nexport function TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nexport function TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nexport function GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nexport function BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nexport function BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush.call(result, instant);\n    }\n    return result;\n}\nexport function ISOYearString(year) {\n    let yearString;\n    if (year < 1000 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `${year}`;\n    }\n    return yearString;\n}\nexport function ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nexport function TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nexport function TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return JSBI.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let µs = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: µs,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n    let nsBigInt, µsBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: µsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nexport function TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nexport function TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nexport function TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nexport function TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nexport function ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nexport function GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n    ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n    ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n    if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = JSBI.toNumber(quotient);\n    let nanos = JSBI.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return JSBI.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nexport function GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n        rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nexport function GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n        leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nexport function GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n    if (JSBI.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = JSBI.add(ns, DAY_NANOS);\n    if (JSBI.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nexport function LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nexport function ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nexport function DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nexport function DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nexport function WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nexport function DurationSign(y, mon, w, d, h, min, s, ms, µs, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = JSBI.BigInt(daysParam);\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n    const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n    const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n    const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n    const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n    const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n    return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n        return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = JSBI.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && JSBI.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = JSBI.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = JSBI.greaterThan(JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nexport function BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = JSBI.toNumber(hoursBigInt) * sign;\n    const minutes = JSBI.toNumber(minutesBigInt) * sign;\n    const seconds = JSBI.toNumber(secondsBigInt) * sign;\n    const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n    const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const addOptions = ObjectCreate(null);\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n                    const untilOptions = ObjectCreate(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            const addOptions = ObjectCreate(null);\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                const addOptions = ObjectCreate(null);\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n                const untilOptions = ObjectCreate(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n        default:\n            // no-op\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, µs, ns) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, µs, ns);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nexport function CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nexport function ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nexport function RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nexport function ValidateEpochNanoseconds(epochNanoseconds) {\n    if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, µs, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nexport function DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n                midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nexport function DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = µs2 - µs1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    deltaDays *= sign;\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = JSBI.subtract(ns2, ns1);\n    const remainder = JSBI.remainder(diff, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = JSBI.add(wholeDays, roundedRemainder);\n    const nanoseconds = JSBI.toNumber(JSBI.remainder(roundedDiff, THOUSAND));\n    const microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = JSBI.toNumber(JSBI.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, µs1, ns1, y2, mon2, d2, h2, min2, s2, ms2, µs2, ns2, calendar, largestUnit, options = ObjectCreate(null)) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2);\n    const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = { ...options, largestUnit: dateLargestUnit };\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = JSBI.subtract(ns2, ns1);\n    if (JSBI.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nexport function AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate(null);\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n        const secondAddOptions = ObjectCreate(null);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function AddInstant(epochNanoseconds, h, min, s, ms, µs, ns) {\n    let sum = ZERO;\n    sum = JSBI.add(sum, JSBI.BigInt(ns));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n    const result = JSBI.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nexport function AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nexport function AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, µs, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, JSBI.BigInt(increment));\n    if (JSBI.equal(remainder, ZERO))\n        return quantity;\n    const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (JSBI.toNumber(abs(JSBI.multiply(remainder, JSBI.BigInt(2)))) >= increment) {\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            }\n            break;\n    }\n    return JSBI.multiply(quotient, JSBI.BigInt(increment));\n}\nexport function RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = JSBI.remainder(epochNs, JSBI.BigInt(86400e9));\n    if (JSBI.lessThan(remainder, ZERO))\n        remainder = JSBI.add(remainder, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return JSBI.add(wholeDays, roundedRemainder);\n}\nexport function RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = JSBI.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const options = ObjectCreate(null);\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nexport function MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nexport function AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n    if (JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = JSBI.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate(null);\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const thirdAddOptions = ObjectCreate(null);\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, thirdAddOptions, dateAdd);\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            const fourthAddOptions = ObjectCreate(null);\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate(null);\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = JSBI.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: JSBI.toNumber(nanoseconds),\n        total\n    };\n}\nexport function CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nexport function ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nexport function ToBigInt(arg) {\n    if (arg instanceof JSBI) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return JSBI.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds = (() => {\n    let ns = JSBI.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = JSBI.BigInt(Date.now());\n        const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n        ns = JSBI.divide(ms, MILLION);\n        if (JSBI.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (JSBI.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nexport function SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nexport function ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nexport function GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nexport function CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = JSBI.BigInt(leftParam);\n    let right = JSBI.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n        const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n//# sourceMappingURL=ecmascript.js.map","const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nexport const zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nexport const time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nexport const yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nexport const monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n//# sourceMappingURL=regex.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { GetSlot, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, TIME_ZONE } from './slots';\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ES.ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst properties = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nexport const DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options and the lib\n    // types for resolved options are less restrictive than the types for options.\n    // For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    if (options['dateStyle'] || options['timeStyle']) {\n        // Unfortunately, Safari's resolvedOptions include parameters that will\n        // cause errors at runtime if passed along with\n        // dateStyle or timeStyle options as per\n        // https://tc39.es/proposal-intl-datetime-style/#table-datetimeformat-components.\n        // This has been fixed in newer versions of Safari:\n        // https://bugs.webkit.org/show_bug.cgi?id=231041\n        delete options['weekday'];\n        delete options['era'];\n        delete options['year'];\n        delete options['month'];\n        delete options['day'];\n        delete options['hour'];\n        delete options['minute'];\n        delete options['second'];\n        delete options['timeZoneName'];\n        delete options['hourCycle'];\n        delete options['hour12'];\n        delete options['dayPeriod'];\n    }\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (ES.IsTemporalDate(obj) ||\n        ES.IsTemporalTime(obj) ||\n        ES.IsTemporalDateTime(obj) ||\n        ES.IsTemporalZonedDateTime(obj) ||\n        ES.IsTemporalYearMonth(obj) ||\n        ES.IsTemporalMonthDay(obj) ||\n        ES.IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y))\n        return false;\n    if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y))\n        return false;\n    if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y))\n        return false;\n    if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y))\n        return false;\n    if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y))\n        return false;\n    if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y))\n        return false;\n    if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (ES.IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (ES.IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (ES.IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (ES.IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (ES.IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (ES.IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ES.ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (ES.IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n//# sourceMappingURL=intl.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\nconst DISALLOWED_UNITS = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nexport class Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ES.ToBigInt(epochNanoseconds);\n        ES.ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        if (DEBUG) {\n            const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = ES.AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        return new Instant(ns);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = ES.AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n        return new Instant(ns);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(this, EPOCHNANOSECONDS);\n        const twons = GetSlot(other, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(other, EPOCHNANOSECONDS);\n        const twons = GetSlot(this, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ES.ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ES.ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ES.ToTemporalTimeZone(item);\n        const calendar = ES.GetISO8601Calendar();\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ES.ToNumber(epochSecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (ES.IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ES.ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalInstant(oneParam);\n        const two = ES.ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(oneNs, twoNs))\n            return -1;\n        if (JSBI.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n//# sourceMappingURL=instant.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst DISALLOWED_UNITS = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nexport class PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalDateLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ES.ToTemporalDateFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalDateFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.DateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToTemporalDuration(temporalDurationLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        const result = ES.CalendarDateUntil(calendar, this, other, untilOptions);\n        if (smallestUnit === 'day' && roundingIncrement === 1)\n            return result;\n        let { years, months, weeks, days } = result;\n        ({ years, months, weeks, days } = ES.RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        let { years, months, weeks, days } = ES.CalendarDateUntil(calendar, this, other, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'day' && roundingIncrement === 1) {\n            return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months, weeks, days } = ES.RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), this));\n        return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (ES.IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ES.ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ES.ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ES.ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDate(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n//# sourceMappingURL=plaindate.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nexport class PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ES.ToIntegerThrowOnInfinity(hourParam);\n        const minute = ES.ToIntegerThrowOnInfinity(minuteParam);\n        const second = ES.ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ES.ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ES.ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ES.ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ES.ToPartialRecord(temporalDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ES.ToTemporalDateTimeFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalDateTimeFields(fields, fieldNames);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = ES.TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = ES.TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDateTime(oneParam);\n        const two = ES.ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n//# sourceMappingURL=plaindatetime.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ES.ToIntegerWithoutRounding(yearsParam);\n        const months = ES.ToIntegerWithoutRounding(monthsParam);\n        const weeks = ES.ToIntegerWithoutRounding(weeksParam);\n        const days = ES.ToIntegerWithoutRounding(daysParam);\n        const hours = ES.ToIntegerWithoutRounding(hoursParam);\n        const minutes = ES.ToIntegerWithoutRounding(minutesParam);\n        const seconds = ES.ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ES.ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ES.ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ES.ToIntegerWithoutRounding(nanosecondsParam);\n        const sign = ES.DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n            if (!Number.isFinite(prop))\n                throw new RangeError('infinite values not allowed as duration fields');\n            const propSign = Math.sign(prop);\n            if (propSign !== 0 && propSign !== sign)\n                throw new RangeError('mixed-sign values not allowed as duration fields');\n        }\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ES.ToPartialRecord(durationLike, [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(other);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    subtract(other, optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(other);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = ES.DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        let smallestUnit = ES.ToSmallestTemporalUnit(options, undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ES.ToLargestTemporalUnit(options, undefined);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('unit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const unit = ES.ToTemporalDurationTotalUnit(options);\n        if (unit === undefined)\n            throw new RangeError('unit option is required');\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return ES.TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (ES.IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ES.ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ES.ToTemporalDuration(oneParam);\n        const two = ES.ToTemporalDuration(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const µs1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const µs2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n        const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n        const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n        return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n//# sourceMappingURL=duration.js.map","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nexport class PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ES.ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalMonthDayLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalMonthDayFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.MonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, receiverFieldNames);\n        const inputFieldNames = ES.CalendarFields(calendar, ['year']);\n        const inputEntries = [['year', undefined]];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = ES.PrepareTemporalFields(item, inputEntries);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalMonthDay(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ES.ToTemporalMonthDay(item, options);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n//# sourceMappingURL=plainmonthday.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.GetISO8601Calendar();\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(ES.GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return ES.SystemTimeZone();\n};\nexport const Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n//# sourceMappingURL=now.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ES.ISODateTimePartString(hour);\n    const minuteString = ES.ISODateTimePartString(minute);\n    const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nexport class PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ES.ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ES.ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ES.ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ES.ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ES.ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ES.ToIntegerThrowOnInfinity(isoNanosecondParam);\n        ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, ES.GetISO8601Calendar());\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const props = ES.ToPartialRecord(temporalTimeLike, [\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'nanosecond',\n            'second'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid time-like');\n        }\n        const fields = ES.ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'hour');\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'hour');\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode)));\n        hours = -hours;\n        minutes = -minutes;\n        seconds = -seconds;\n        milliseconds = -milliseconds;\n        microseconds = -microseconds;\n        nanoseconds = -nanoseconds;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ES.ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        if (ES.IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ES.ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalTime(oneParam);\n        const two = ES.ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n//# sourceMappingURL=plaintime.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { TIMEZONE_ID, EPOCHNANOSECONDS, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            return ES.ParseTimeZoneOffsetString(id);\n        }\n        return ES.GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        return ES.BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = ES.GetISO8601Calendar()) {\n        const instant = ES.ToTemporalInstant(instantParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        return ES.BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            const epochNs = ES.GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ES.ParseTimeZoneOffsetString(id);\n            return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = ES.GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalTimeZone(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n//# sourceMappingURL=timezone.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = [\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nexport class PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = ES.GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISODay = ES.ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalYearMonthLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalYearMonthFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.YearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const sign = ES.DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ES.ToPositiveInteger(ES.CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = ES.DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = ES.CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ES.ToTemporalYearMonthFields(addedDate, fieldNames);\n        return ES.YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        let duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const sign = ES.DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ES.ToPositiveInteger(ES.CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = ES.DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = ES.CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ES.ToTemporalYearMonthFields(addedDate, fieldNames);\n        return ES.YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ES.ToString(calendar);\n        const otherCalendarID = ES.ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ES.ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = ES.DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = ES.DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        const result = ES.CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        if (smallestUnit === 'month' && roundingIncrement === 1)\n            return result;\n        let { years, months } = result;\n        ({ years, months } = ES.RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ES.ToString(calendar);\n        const otherCalendarID = ES.ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ES.ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = ES.DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = ES.DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        let { years, months } = ES.CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'month' && roundingIncrement === 1) {\n            return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months } = ES.RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), thisDate));\n        return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, receiverFieldNames);\n        const inputFieldNames = ES.CalendarFields(calendar, ['day']);\n        const inputEntries = [['day']];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([\n                    fieldName,\n                    undefined\n                ]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = ES.PrepareTemporalFields(item, inputEntries);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalYearMonth(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ES.ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalYearMonth(oneParam);\n        const two = ES.ToTemporalYearMonth(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n//# sourceMappingURL=plainyearmonth.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, EPOCHNANOSECONDS, ISO_HOUR, INSTANT, ISO_DAY, ISO_MONTH, ISO_YEAR, ISO_MICROSECOND, ISO_MILLISECOND, ISO_MINUTE, ISO_NANOSECOND, ISO_SECOND, TIME_ZONE, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO } from './ecmascript';\nconst ArrayPrototypePush = Array.prototype.push;\nexport class ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = ES.GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const offset = ES.ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        ArrayPrototypePush.call(fieldNames, 'offset');\n        const props = ES.ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n        const entries = [\n            ['day', undefined],\n            ['hour', 0],\n            ['microsecond', 0],\n            ['millisecond', 0],\n            ['minute', 0],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['nanosecond', 0],\n            ['second', 0],\n            ['year', undefined],\n            ['offset'],\n            ['timeZone']\n        ];\n        // Add extra fields from the calendar at the end\n        fieldNames.forEach((fieldName) => {\n            if (!entries.some(([name]) => name === fieldName)) {\n                entries.push([fieldName, undefined]);\n            }\n        });\n        let fields = ES.PrepareTemporalFields(this, entries);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, entries);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = ES.AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = ES.AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!ES.TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        let roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        roundingMode = ES.NegateTemporalRoundingMode(roundingMode);\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!ES.TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (JSBI.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        JSBI.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two)))\n            return false;\n        if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const showTimeZone = ES.ToShowTimeZoneNameOption(options);\n        const showOffset = ES.ToShowOffsetOption(options);\n        return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: ES.BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalZonedDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            ES.ToTemporalDisambiguation(options);\n            ES.ToTemporalOffset(options, 'reject');\n            return ES.CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalZonedDateTime(oneParam);\n        const two = ES.ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return -1;\n        if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n//# sourceMappingURL=zoneddatetime.js.map","import { Instant } from './instant';\nimport JSBI from 'jsbi';\nimport * as ES from './ecmascript';\nimport { MILLION } from './ecmascript';\nexport function toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n    return new Instant(ES.ToBigInt(epochNanoseconds));\n}\n//# sourceMappingURL=legacydate.js.map","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Temporal.Instant,\n    Temporal.Calendar,\n    Temporal.PlainDate,\n    Temporal.PlainDateTime,\n    Temporal.Duration,\n    Temporal.PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    Temporal.PlainTime,\n    Temporal.TimeZone,\n    Temporal.PlainYearMonth,\n    Temporal.ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\nexport { Temporal, Intl, toTemporalInstant };\n//# sourceMappingURL=index.js.map"],"names":["INTRINSICS","MakeIntrinsicClass","Class","name","Object","defineProperty","prototype","Symbol","toStringTag","value","writable","enumerable","configurable","prop","getOwnPropertyNames","desc","getOwnPropertyDescriptor","DefineIntrinsic","key","undefined","Error","GetIntrinsic","intrinsic","EPOCHNANOSECONDS","TIMEZONE_ID","ISO_YEAR","ISO_MONTH","ISO_DAY","ISO_HOUR","ISO_MINUTE","ISO_SECOND","ISO_MILLISECOND","ISO_MICROSECOND","ISO_NANOSECOND","CALENDAR","INSTANT","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","CALENDAR_ID","slots","WeakMap","CreateSlots","container","set","create","GetSlots","get","HasSlot","ids","myslots","reduce","all","id","GetSlot","TypeError","SetSlot","ArrayIncludes","Array","includes","ArrayPrototypePush","push","IntlDateTimeFormat","globalThis","Intl","DateTimeFormat","ArraySort","sort","MathAbs","Math","abs","MathFloor","floor","ObjectEntries","entries","ObjectKeys","keys","impl","Calendar","constructor","idParam","arguments","length","RangeError","ES.ToString","IsBuiltinCalendar","this","ES.IsTemporalCalendar","dateFromFields","fields","optionsParam","ES.IsObject","options","ES.GetOptionsObject","yearMonthFromFields","monthDayFromFields","fieldsArray","allowed","Set","has","delete","call","mergeFields","additionalFields","dateAdd","dateParam","durationParam","date","ES.ToTemporalDate","duration","ES.ToTemporalDuration","overflow","ES.ToTemporalOverflow","days","ES.BalanceDuration","dateUntil","oneParam","twoParam","one","two","largestUnit","ES.ToLargestTemporalUnit","years","months","weeks","year","ES.IsTemporalYearMonth","month","ES.IsTemporalMonthDay","monthCode","day","era","eraYear","dayOfWeek","dayOfYear","weekOfYear","daysInWeek","daysInMonth","daysInYear","monthsInYear","inLeapYear","toString","toJSON","from","item","ES.ToTemporalCalendar","monthCodeNumberPart","startsWith","slice","isNaN","buildMonthCode","leap","padStart","resolveNonLunisolarMonth","calendarDate","monthsPerYear","ES.RejectToRange","ES.ConstrainToRange","numberPart","fieldsParam","calendar","ES.PrepareTemporalFields","ES.RegulateISODate","ES.CreateTemporalDate","RegulateISOYearMonth","yearParam","monthParam","referenceISODay","RejectISODate","ConstrainISODate","ES.RegulateISOYearMonth","ES.CreateTemporalYearMonth","useYear","ES.CreateTemporalMonthDay","merged","nextKey","newKeys","ES.AddISODate","ES.DifferenceISODate","ES.DayOfWeek","ES.DayOfYear","WeekOfYear","doy","DayOfYear","dow","DayOfWeek","doj","week","LeapYear","ES.WeekOfYear","ES.ISODaysInMonth","ES.LeapYear","OneObjectCache","cacheToClone","map","Map","calls","hits","misses","now","performance","Date","i","entry","MAX_CACHE_ENTRIES","result","report","setObject","obj","objectMap","getCacheForObject","cache","toUtcIsoDateString","isoYear","isoMonth","isoDay","ES.ISOYearString","ES.ISODateTimePartString","simpleDateDiff","HelperBase","eraLength","hasEra","getFormatter","formatter","timeZone","isoToCalendarDate","isoDate","JSON","stringify","func","cached","dateTimeFormat","parts","isoString","formatToParts","e","type","matches","exec","monthExtra","split","normalize","replace","toLowerCase","reviseIntlEra","checkIcuBugs","adjustCalendarDate","forEach","keyReverse","validateCalendarDate","test","constantEra","calendarDateParam","fromLegacyDate","calendarType","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","originalDate","keyOriginal","isoEstimate","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","minimumMonthLength","testCalendarDate","sign","roundtripEstimate","diff","diffTotalDaysEstimate","compareCalendarDates","increment","maybeConstrained","oldRoundtripEstimate","oldSign","temporalToCalendarDate","date1Param","date2Param","date1","date2","ES.ComparisonResult","regulateDate","addDaysCalendar","addedIso","addMonthsCalendar","absMonths","oldCalendarDate","max","daysInPreviousMonth","monthsInOldYear","addCalendar","addedMonths","initialDays","untilCalendar","calendarOne","calendarTwo","calendarDaysUntil","totalDays","diffYears","diffMonths","current","next","min","addedIsoDate","addedCalendarDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","startOfCalendarYear","startOfCalendarMonth","oneIso","twoIso","isoDaysUntil","closestCalendar","closestIso","calendarYear","roundTripCalendarDate","HebrewHelper","super","Tishri","regular","Heshvan","Kislev","Tevet","Shevat","Adar","Nisan","Iyar","Sivan","Tamuz","Av","Elul","minMaxMonthLength","minOrMax","getMonthCode","monthInfo","find","m","endsWith","IslamicBaseHelper","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","IslamicHelper","IslamicUmalquraHelper","IslamicTblaHelper","IslamicCivilHelper","IslamicRgsaHelper","IslamicCcHelper","PersianHelper","IndianHelper","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","GregorianBaseHelper","originalEras","v8IsVulnerableToJulianBug","calendarIsVulnerableToJulianBug","eras","anchorEra","adjustEras","erasParam","reverseOf","filter","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","genericName","indexOf","completeEraYear","checkField","currentValue","eraFromYear","adjustedCalendarDate","matchingEra","ES.CompareISODate","OrthodoxBaseHelper","EthioaaHelper","CopticHelper","EthiopicHelper","RocHelper","BuddhistHelper","GregoryHelper","JapaneseHelper","ChineseBaseHelper","getMonthList","getCalendarDate","daysPastFeb1","isoStringFeb1","legacyDate","setUTCDate","newYearGuess","calendarMonthString","tv","calendarDay","calendarYearToVerify","isoDaysDelta","oldCalendarDay","oldMonthString","monthIndex","done","monthString","withoutML","monthEntries","matchingMonthEntry","v","ChineseHelper","DangiHelper","nonIsoImpl","helper","fieldsCopy","additionalFieldsCopy","original","newMonth","newMonthCode","newYear","newEra","newEraYear","added","isoAdded","newTemporalObject","cacheOne","cacheTwo","startOfYear","startOfMonthCalendar","startOfNextMonthCalendar","startOfYearCalendar","startOfNextYearCalendar","Helper","BUILTIN_CALENDAR_IDS","tzComponent","timeZoneID","RegExp","source","calComponent","calendarID","yearpart","monthpart","daypart","datesplit","timesplit","offset","zonesplit","zoneddatetime","time","yearmonth","monthday","fraction","durationTime","MathMin","MathMax","MathSign","MathTrunc","trunc","NumberIsNaN","Number","NumberIsFinite","isFinite","NumberCtor","StringCtor","String","NumberMaxSafeInteger","MAX_SAFE_INTEGER","ObjectCreate","ObjectIs","is","ReflectApply","Reflect","apply","ZERO","JSBI","BigInt","ONE","SIXTY","THOUSAND","MILLION","BILLION","NEGATIVE_ONE","DAY_NANOS","multiply","NS_MIN","NS_MAX","BEFORE_FIRST_OFFSET_TRANSITION","ABOUT_TEN_YEARS_NANOS","ABOUT_ONE_YEAR_NANOS","TWO_WEEKS_NANOS","IsInteger","IsObject","ToNumber","ToInteger","num","integer","ToString","ToIntegerThrowOnInfinity","ToPositiveInteger","valueParam","property","ToIntegerWithoutRounding","divmod","x","y","quotient","divide","remainder","lessThan","BUILTIN_CASTS","ALLOWED_UNITS","SINGULAR_PLURAL_UNITS","IntlDateTimeFormatEnUsCache","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","instance","hour12","hour","minute","second","IsTemporalInstant","IsTemporalTimeZone","IsTemporalCalendar","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","RejectObjectWithCalendarOrTimeZone","ParseTemporalTimeZone","stringIdent","ianaName","z","ParseTemporalTimeZoneString","canonicalIdent","GetCanonicalTimeZoneIdentifier","TestTimeZoneOffsetString","ParseISODateTime","FormatCalendarAnnotation","showCalendar","match","PARSE.zoneddatetime","yearString","hasTime","millisecond","microsecond","nanosecond","offsetSign","offsetHours","offsetMinutes","offsetSeconds","offsetFraction","ParseTemporalYearMonthString","PARSE.yearmonth","ParseTemporalMonthDayString","PARSE.monthday","referenceISOYear","ParseTemporalDurationString","PARSE.duration","every","element","hours","fHours","minutes","fMinutes","seconds","fSeconds","milliseconds","microseconds","nanoseconds","DurationHandleFractions","fHoursParam","minutesParam","fMinutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","val","mins","secs","mils","fMilliseconds","mics","fMicroseconds","ParseTemporalInstant","ParseTemporalInstantString","epochNs","GetEpochFromISOParts","offsetNs","ParseTimeZoneOffsetString","subtract","RegulateISODate","dayParam","RegulateTime","hourParam","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","RejectTime","ConstrainTime","ConstrainToRange","ToTemporalDurationRecord","props","ToPartialRecord","ToLimitedTemporalDuration","disallowedProperties","record","RejectDuration","ToTemporalOverflow","GetOption","ToTemporalDisambiguation","ToTemporalRoundingMode","fallback","NegateTemporalRoundingMode","roundingMode","ToTemporalOffset","ToShowCalendarOption","ToTemporalRoundingIncrement","dividend","inclusive","maximum","Infinity","GetNumberOption","minimum","valueRaw","ToTemporalDateTimeRoundingIncrement","smallestUnit","ToSecondsStringPrecision","ToSmallestTemporalUnit","precision","unit","digits","fractionalSecondDigits","stringDigits","ToLargestTemporalUnit","disallowedStrings","autoValue","singular","sing","s","retval","ToRelativeTemporalObject","relativeTo","offsetBehaviour","matchMinutes","TemporalDateTimeToDate","GetTemporalCalendarWithISODefault","ToTemporalDateTimeFields","CalendarFields","dateOptions","InterpretTemporalDateTimeFields","GetISO8601Calendar","ToTemporalCalendar","ToTemporalTimeZone","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","CreateTemporalDate","ValidateTemporalUnitRange","DefaultTemporalLargestUnit","LargerOfTwoTemporalUnits","unit1","unit2","bagParam","bag","any","PrepareTemporalFields","fieldRecord","defaultValue","ToTemporalDateFields","fieldNames","fieldName","some","ToTemporalMonthDayFields","ToTemporalTimeRecord","ToTemporalYearMonthFields","ToTemporalDate","itemParam","BuiltinTimeZoneGetPlainDateTimeFor","DateFromFields","ParseTemporalDateString","ToTemporalDateTime","CreateTemporalDateTime","ParseTemporalDateTimeString","RejectDateTime","ToTemporalDuration","ToTemporalInstant","ns","ToTemporalMonthDay","calendarAbsent","maybeStringCalendar","MonthDayFromFields","CreateTemporalMonthDay","ToTemporalTime","ParseTemporalTimeString","PARSE.time","ToTemporalYearMonth","YearMonthFromFields","CreateTemporalYearMonth","disambiguation","offsetOpt","matchMinute","dt","BuiltinTimeZoneGetInstantFor","possibleInstants","GetPossibleInstantsFor","candidate","candidateOffset","GetOffsetNanosecondsFor","roundedCandidateOffset","toNumber","RoundNumberToIncrement","offsetStr","FormatTimeZoneOffsetString","timeZoneString","DisambiguatePossibleInstants","ToTemporalZonedDateTime","ToTemporalZonedDateTimeFields","ParseTemporalZonedDateTimeString","CreateTemporalDateSlots","RejectDateRange","TemporalPlainDate","CreateTemporalDateTimeSlots","h","ms","RejectDateTimeRange","TemporalPlainDateTime","CreateTemporalMonthDaySlots","TemporalPlainMonthDay","CreateTemporalYearMonthSlots","RejectYearMonthRange","RejectToRange","TemporalPlainYearMonth","CreateTemporalZonedDateTimeSlots","epochNanoseconds","ValidateEpochNanoseconds","instant","TemporalZonedDateTime","fieldNamesParam","CalendarMergeFields","calMergeFields","CalendarDateAdd","dateAddParam","CalendarDateUntil","otherDate","dateUntilParam","CalendarYear","dateLike","CalendarMonth","CalendarMonthCode","CalendarDay","CalendarEra","CalendarEraYear","CalendarDayOfWeek","CalendarDayOfYear","CalendarWeekOfYear","CalendarDaysInWeek","CalendarDaysInMonth","CalendarDaysInYear","CalendarMonthsInYear","CalendarInLeapYear","calendarLikeParam","calendarLike","identifier","TemporalCalendar","CalendarEquals","ConsolidateCalendars","sOne","sTwo","temporalTimeZoneLikeParam","temporalTimeZoneLike","TimeZoneEquals","dateTime","TemporalDateTimeToTime","getOffsetNanosecondsFor","BuiltinTimeZoneGetOffsetStringFor","GetISOPartsFromEpoch","BalanceISODateTime","Instant","numInstants","utcns","dayBefore","dayAfter","add","offsetBefore","PlainDateTime","earlier","AddDateTime","later","possible","getPossibleInstantsFor","ISOYearString","ISODateTimePartString","part","FormatSecondsStringPart","fractionNumber","TemporalInstantToString","outputTimeZone","FormatISOTimeZoneOffsetString","TemporalDurationToString","formatNumber","DurationSign","RoundDuration","dateParts","timeParts","secondParts","nsBigInt","msBigInt","secondsBigInt","total","TotalDurationNanoseconds","decimalPart","unshift","equal","join","TemporalDateToString","TemporalDateTimeToString","RoundISODateTime","TemporalMonthDayToString","monthDay","resultString","calendarString","TemporalYearMonthToString","yearMonth","TemporalZonedDateTimeToString","zdt","showTimeZone","showOffset","RoundInstant","tz","string","OFFSET","resolvedOptions","GetIANATimeZoneOffsetNanoseconds","GetIANATimeZoneDateTimeParts","utc","offsetNanosecondsParam","offsetNanoseconds","hourString","minuteString","secondString","post","setUTCHours","setUTCFullYear","getTime","greaterThan","epochMilliseconds","nanos","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetFormatterParts","parseFromEnUsFormat","datetime","toUpperCase","format","maxJSBI","afterLatestPossibleTzdbRuleChange","SystemUTCEpochNanoSeconds","GetIANATimeZonePreviousTransition","afterLatestRule","isFarFuture","lowercap","rightNanos","rightOffsetNs","leftNanos","leftOffsetNs","bisect","ISODaysInMonth","standard","leapyear","Y","c","mon","w","d","BalanceISOYearMonth","BalanceISODate","testYear","deltaDays","BalanceTime","NonNegativeModulo","daysParam","hoursParam","offsetShift","NanosecondsToDays","TemporalInstant","dayLengthNs","startNs","start","endNs","end","dtStart","dtEnd","DifferenceISODateTime","intermediateNs","AddZonedDateTime","isOverflow","relativeInstant","oneDayFartherNs","relativeNs","BalanceDuration","nanosecondsBigInt","microsecondsBigInt","millisecondsBigInt","minutesBigInt","hoursBigInt","UnbalanceDurationRelative","yearsParam","monthsParam","weeksParam","relativeToParam","TemporalDuration","oneYear","oneMonth","oneWeek","relativeToDateOnly","newRelativeTo","untilOptions","oneYearMonths","oneYearDays","MoveRelativeDate","oneMonthDays","oneWeekDays","CalculateOffsetShift","after","CreateNegatedTemporalDuration","propSign","DifferenceISODate","y1","m1","d1","y2","m2","d2","CompareISODate","mid","AddISODate","midSign","larger","smaller","DifferenceTime","h1","min1","s1","ms1","ns1","h2","min2","s2","ms2","ns2","DifferenceInstant","wholeDays","roundedRemainder","nsPerTimeUnit","roundedDiff","y1Param","mon1Param","d1Param","mon2","mon1","timeSign","DifferenceZonedDateTime","nsDiff","timeRemainderNs","intermediate","AddTime","AddDuration","w1","w2","dateDuration1","dateDuration2","dateLargestUnit","differenceOptions","AddInstant","sum","addedDate","dtIntermediate","quantity","mode","RoundTime","nsPerUnit","rounded","DaysUntil","MoveRelativeZonedDateTime","AdjustRoundedDurationDays","direction","dayStart","dayEnd","greaterThanOrEqual","zdtRelative","dayLength","yearsDuration","yearsLater","yearsMonthsWeeksLater","daysLater","yearsPassed","oldRelativeTo","divisor","yearsMonths","yearsMonthsLater","allNanoseconds","ComparisonResult","ToBigIntExternal","arg","jsbiBI","ToBigInt","prim","toPrimFn","toPrimitive","SyntaxError","message","GetOptionsObject","CreateOnePropObject","propName","propValue","o","allowedValues","PARSE.offset","getState","leftParam","rightParam","lstateParam","rstateParam","left","right","lstate","rstate","middle","mstate","DATE","YM","MD","TIME","DATETIME","ZONED","INST","ORIGINAL","TZ_RESOLVED","TZ_GIVEN","CAL_ID","LOCALE","OPTIONS","descriptor","ObjectAssign","assign","ObjectHasOwnProperty","hasOwnProperty","getPropLazy","getResolvedTimeZoneLazy","ES.ToTemporalTimeZone","DateTimeFormatImpl","locale","hasOptions","ro","clonedResolved","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","datetimeAmend","zonedDateTimeAmend","instantAmend","supportedLocalesOf","locales","properties","rest","extractOverrides","adjustFormatterTimeZone","formatRange","a","b","isTemporalObject","sameTemporalType","aa","aformatter","atz","bb","bformatter","btz","formatRangeToParts","amend","amended","opt","weekday","timeZoneName","dateStyle","hasTimeOptions","dayPeriod","timeStyle","hasDateOptions","ES.IsTemporalDate","ES.IsTemporalTime","ES.IsTemporalDateTime","ES.IsTemporalZonedDateTime","ES.IsTemporalInstant","temporalObj","main","DateTime","ES.BuiltinTimeZoneGetInstantFor","objTimeZone","DISALLOWED_UNITS","MAX_DIFFERENCE_INCREMENTS","ES.ToBigInt","ES.ValidateEpochNanoseconds","epochSeconds","epochMicroseconds","ES.ToBigIntExternal","temporalDurationLike","ES.ToLimitedTemporalDuration","ES.AddInstant","until","otherParam","other","ES.ToTemporalInstant","ES.ToSmallestTemporalUnit","defaultLargestUnit","ES.LargerOfTwoTemporalUnits","ES.ValidateTemporalUnitRange","ES.ToTemporalRoundingMode","roundingIncrement","ES.ToTemporalRoundingIncrement","onens","twons","ES.DifferenceInstant","since","round","ES.CreateOnePropObject","roundedNs","ES.RoundInstant","equals","ES.ToSecondsStringPrecision","ES.TemporalInstantToString","toLocaleString","valueOf","toZonedDateTime","ES.CreateTemporalZonedDateTime","toZonedDateTimeISO","timeZoneProperty","ES.GetISO8601Calendar","fromEpochSeconds","epochSecondsParam","ES.ToNumber","fromEpochMilliseconds","epochMillisecondsParam","fromEpochMicroseconds","epochMicrosecondsParam","fromEpochNanoseconds","epochNanosecondsParam","compare","oneNs","twoNs","PlainDate","isoYearParam","isoMonthParam","isoDayParam","calendarParam","ES.ToIntegerThrowOnInfinity","ES.CreateTemporalDateSlots","ES.CalendarEra","ES.CalendarEraYear","ES.CalendarYear","ES.CalendarMonth","ES.CalendarMonthCode","ES.CalendarDay","ES.CalendarDayOfWeek","ES.CalendarDayOfYear","ES.CalendarWeekOfYear","ES.CalendarDaysInWeek","ES.CalendarDaysInMonth","ES.CalendarDaysInYear","ES.CalendarMonthsInYear","ES.CalendarInLeapYear","with","temporalDateLike","ES.RejectObjectWithCalendarOrTimeZone","ES.CalendarFields","ES.ToPartialRecord","ES.ToTemporalDateFields","ES.CalendarMergeFields","ES.DateFromFields","withCalendar","ES.CalendarDateAdd","ES.CreateNegatedTemporalDuration","otherCalendar","calendarId","otherCalendarId","ES.CalendarDateUntil","ES.RoundDuration","Duration","ES.NegateTemporalRoundingMode","slot","ES.CalendarEquals","ES.TemporalDateToString","ES.ToShowCalendarOption","toPlainDateTime","temporalTimeParam","ES.CreateTemporalDateTime","temporalTime","ES.ToTemporalTime","timeZoneLike","plainTime","toPlainYearMonth","ES.YearMonthFromFields","ES.ToTemporalYearMonthFields","toPlainMonthDay","ES.MonthDayFromFields","ES.ToTemporalMonthDayFields","getISOFields","ES.CreateTemporalDateTimeSlots","temporalDateTimeLike","ES.ToTemporalDateTimeFields","ES.InterpretTemporalDateTimeFields","withPlainTime","withPlainDate","temporalDateParam","temporalDate","ES.ConsolidateCalendars","ES.AddDateTime","ES.ToTemporalDateTime","ES.ToTemporalDateTimeRoundingIncrement","ES.DifferenceISODateTime","ES.TemporalDateTimeToDate","ES.RoundISODateTime","ES.TemporalDateTimeToString","ES.ToTemporalDisambiguation","toPlainDate","toPlainTime","ES.TemporalDateTimeToTime","isoHour","isoMicrosecond","isoMillisecond","isoMinute","isoNanosecond","isoSecond","val1","val2","ES.ToIntegerWithoutRounding","ES.DurationSign","ES.IsTemporalDuration","blank","durationLike","negated","ES.ToRelativeTemporalObject","ES.AddDuration","ES.DefaultTemporalLargestUnit","smallestUnitPresent","largestUnitPresent","ES.UnbalanceDurationRelative","ES.AdjustRoundedDurationDays","BalanceDurationRelative","untilResult","ES.BalanceDurationRelative","ES.MoveRelativeZonedDateTime","ToTemporalDurationTotalUnit","values","ES.ToTemporalDurationTotalUnit","ES.TemporalDurationToString","DurationFormat","console","warn","shift1","ES.CalculateOffsetShift","shift2","totalNs1","ES.TotalDurationNanoseconds","totalNs2","PlainMonthDay","referenceISOYearParam","ES.CreateTemporalMonthDaySlots","temporalMonthDayLike","ES.ToTemporalMonthDay","ES.TemporalMonthDayToString","receiverFieldNames","inputFieldNames","inputEntries","mergedFields","mergedFieldNames","mergedEntries","ES.SystemUTCEpochNanoSeconds","plainDateTime","tZ","ES.BuiltinTimeZoneGetPlainDateTimeFor","plainDateTimeISO","zonedDateTime","SystemTimeZone","fmt","ES.SystemTimeZone","Now","plainDate","plainDateISO","plainTimeISO","zonedDateTimeISO","MAX_INCREMENTS","TemporalTimeToString","ES.RoundTime","ES.FormatSecondsStringPart","PlainTime","isoHourParam","isoMinuteParam","isoSecondParam","isoMillisecondParam","isoMicrosecondParam","isoNanosecondParam","ES.RejectTime","temporalTimeLike","ES.ToTemporalTimeRecord","ES.RegulateTime","ES.AddTime","ES.DifferenceTime","TimeZone","timeZoneIdentifierParam","ES.GetCanonicalTimeZoneIdentifier","ES.IsTemporalTimeZone","instantParam","ES.TestTimeZoneOffsetString","ES.ParseTimeZoneOffsetString","ES.GetIANATimeZoneOffsetNanoseconds","getOffsetStringFor","ES.BuiltinTimeZoneGetOffsetStringFor","getPlainDateTimeFor","getInstantFor","dateTimeParam","ES.GetEpochFromISOParts","GetIANATimeZoneEpochValue","nsEarlier","nsLater","earliest","latest","ES.GetIANATimeZoneEpochValue","getNextTransition","startingPointParam","startingPoint","GetIANATimeZoneNextTransition","oneYearLater","uppercap","ES.GetIANATimeZoneNextTransition","getPreviousTransition","ES.GetIANATimeZonePreviousTransition","PlainYearMonth","referenceISODayParam","ES.CreateTemporalYearMonthSlots","temporalYearMonthLike","startDate","ES.ToPositiveInteger","optionsCopy","ES.ToTemporalYearMonth","otherCalendarID","otherFields","thisFields","thisDate","ES.TemporalYearMonthToString","ZonedDateTime","timeZoneParam","ES.CreateTemporalZonedDateTimeSlots","hoursInDay","today","tomorrowFields","tomorrow","todayNs","tomorrowNs","ES.GetOffsetNanosecondsFor","temporalZonedDateTimeLike","ES.ToTemporalOffset","ES.InterpretISODateTimeOffset","thisDt","withTimeZone","ES.AddZonedDateTime","ES.ToTemporalZonedDateTime","ES.TimeZoneEquals","ES.DifferenceZonedDateTime","instantStart","ES.TemporalZonedDateTimeToString","ToShowTimeZoneNameOption","ES.ToShowTimeZoneNameOption","ToShowOffsetOption","ES.ToShowOffsetOption","startOfDay","toInstant","toTemporalInstant","types","Temporal.Instant","Temporal.Calendar","Temporal.PlainDate","Temporal.PlainDateTime","Temporal.Duration","Temporal.PlainMonthDay","Temporal.PlainTime","Temporal.TimeZone","Temporal.PlainYearMonth","Temporal.ZonedDateTime"],"mappings":"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"}